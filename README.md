## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2501`

#### Выполнил: `Калинин Арсений Александрович`

#### Вариант: `9`

### Cодержание:

- [Первая задача](#1-вывод-закономерности-последовательности)
- [Вторая задача](#2-максимальное-число-подъёмов)
- [Третья задача](#3-вывод-самой-младшей-нечётной-цифры)
- [Четвёртая задача](#4-циклический-сдвиг)

### 1. Вывод закономерности последовательности

### 1.1 Постановка задачи

> С клавиатуры вводятся два целых числа: первое число последовательности (`first`) и количество элементов для вывода (`count`). 
> Последовательность строится по правилу: 
> - если индекс текущего элемента чётный, то к предыдущему элементу прибавляется 4
> - если индекс нечётный, то предыдущий элемент умножается на 3
> 
> Вывести первые `count` элементов последовательности, начиная с вычисленного по правилу значения.

### 1.2 Входные и выходные данные

#### Входные данные
Два целых числа:
1. `first` — начальное значение последовательности
2. `count` — количество элементов для вывода

| Параметр | Тип данных | Диапазон значений                |
|----------|------------|----------------------------------|
| `first`  | `int`      | -2147483648 ≤ first ≤ 2147483647 |
| `count`  | `int`      | 0 ≤ count ≤ 100                  |

#### Выходные данные
`count` целых чисел — элементы последовательности, разделённые пробелами.

### 1.3 Выбор структуры данных

| Параметр        | Имя переменной | Тип данных | Назначение                     |
|-----------------|----------------|------------|--------------------------------|
| Начальное число | `first`        | `int`      | Хранит начальное значение      |
| Количество      | `count`        | `int`      | Количество выводимых элементов |
| Счётчик цикла   | `i`            | `int`      | Управление циклом              |

### 1.4 Алгоритм

1. Считать два числа `first` и `count`
2. Использовать цикл `for` от 0 до `count-1`
3. На каждой итерации:
   - Если индекс `i` чётный (`i % 2 == 0`): `first = first + 4`
   - Если индекс `i` нечётный: `first = first * 3`
   - Вывести текущее значение `first`
4. После завершения цикла программа завершается

### 1.5 Программа

```java
package task1;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int first = in.nextInt();
        int count = in.nextInt();
        for(int i = 0; i < count; i++){
            if(i % 2 == 0) first += 4;
            else first *= 3;
            out.print(first + " ");
        }
    }
}
```

### 1.6 Анализ правильности решения

1. **Тест 1:** Первый элемент вычисляется сразу
   ```
   Вход: 1 3
   Выход: 5 15 19
   ```

2. **Тест 2:** Корректное чередование операций
   ```
   Вход: 0 5
   Выход: 4 12 16 48 52
   ```

3. **Тест 3:** Один элемент
   ```
   Вход: 10 1
   Выход: 14
   ```

4. **Тест 4:** Большие значения
   ```
   Вход: 100000000 2
   Выход: 100000004 300000012
   ```

---

### 2. Максимальное число подъёмов

### 2.1 Постановка задачи

> Дана последовательность из `n` целых чисел. Элементы с одинаковой чётностью, идущие подряд, образуют "часть". 
> Для каждой части нужно подсчитать количество "подъёмов" — случаев, когда текущий элемент последовательности **строго больше** предыдущего.
> Вывести максимальное количество подъёмов среди всех частей.

### 2.2 Входные и выходные данные

#### Входные данные
1. `count` — количество элементов в последовательности
2. `count` целых чисел — сама последовательность

| Параметр | Тип данных | Диапазон значений            |
|----------|------------|------------------------------|
| `count`  | `int`      | 1 ≤ count ≤ 2147483647       |
| Элементы | `int`      | -2147483648 ≤ x ≤ 2147483647 |

#### Выходные данные
Одно целое число — максимальное количество подъёмов в какой-либо части последовательности.

### 2.3 Выбор структуры данных

| Параметр                 | Имя переменной | Тип данных | Назначение                       |
|--------------------------|----------------|------------|----------------------------------|
| Количество элементов     | `count`        | `int`      | Длина последовательности         |
| Текущий элемент          | `el`           | `int`      | Хранит текущий элемент           |
| Предыдущий элемент       | `past`         | `int`      | Хранит предыдущий элемент        |
| Счётчик для чётных       | `j`            | `int`      | Подъёмы в текущей чётной части   |
| Счётчик для нечётных     | `k`            | `int`      | Подъёмы в текущей нечётной части |
| Результат                | `result`       | `int`      | Максимальное найденное значение  |

### 2.4 Алгоритм

1. Считать количество элементов `count` и первый элемент `el`
2. Инициализировать переменные: `result = 0`, `j = 0`, `k = 0`
3. Для каждого следующего элемента (от второго до последнего):
   - Сохранить предыдущий элемент в `past`
   - Считать новый элемент в `el`
   - Проверить условия:
     - Если оба чётные И оба не равны 0: если `el > past`, увеличить `j`, иначе сбросить `k = 0`
     - Если оба нечётные: если `el > past`, увеличить `k`, иначе сбросить `j = 0`
   - Обновить `result` максимальным значением из `j`, `k`, `result`
4. Вывести `result`

### 2.5 Программа

```java
package task2;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int count = in.nextInt();
        int el = in.nextInt();
        int result = 0;
        int j = 0, k = 0;
        for(int i = 1; i < count; i++){
            int past = el;
            el = in.nextInt();
            if(el % 2 == 0 && past % 2 == 0 && el != 0 && past != 0){
                if(el > past) j++;
                k = 0;
            }
            else if(el % 2 != 0 && past % 2 != 0){
                if(el > past) k++;
                j = 0;
            }
            if(k > result) result = k;
            if(j > result) result = j;
        }
        out.print(result);
    }
}
```

### 2.6 Анализ правильности решения

1. **Тест 1:** Только чётные числа
   ```
   Вход: 5
         2 4 6 8 10
   Выход: 4
   ```

2. **Тест 2:** Только нечётные числа
   ```
   Вход: 4
         1 3 5 2
   Выход: 2
   ```

3. **Тест 3:** Смена чётности
   ```
   Вход: 6
         1 3 2 4 6 8
   Выход: 3
   ```

4. **Тест 4:** Содержит 0
   ```
   Вход: 5
         0 2 4 0 6
   Выход: 1
   ```

---

### 3. Вывод самой младшей нечётной цифры

### 3.1 Постановка задачи

> Дано натуральное число N. Необходимо найти **самую младшую** (самую правую) нечётную цифру в его десятичной записи. 
> Если в числе нет нечётных цифр, вывести "NO".

### 3.2 Входные и выходные данные

#### Входные данные
Одно натуральное число N.

| Параметр | Тип данных | Диапазон значений    |
|----------|------------|----------------------|
| `num`    | `int`      | 1 ≤ num ≤ 2147483647 |

#### Выходные данные
- Если найдена нечётная цифра: эта цифра
- Иначе: "NO"

### 3.3 Выбор структуры данных

| Параметр            | Имя переменной | Тип данных | Назначение             |
|---------------------|----------------|------------|------------------------|
| Входное число       | `num`          | `int`      | Исходное число         |
| Найденная цифра     | `el`           | `int`      | Младшая нечётная цифра |

### 3.4 Алгоритм

1. Считать число `num`
2. Инициализировать `el = 0`
3. Пока `el == 0` и `num > 0`:
   - Проверить последнюю цифру: если `num % 10 % 2 != 0`, то `el = num % 10`
   - Удалить последнюю цифру: `num = num / 10`
4. Если `el == 0`, вывести "NO"
5. Иначе вывести `el`

### 3.5 Программа

```java
package task3;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int num = in.nextInt();
        int el = 0;
        while(el == 0){
            if(num % 10 % 2 != 0) el = num % 10;
            num /= 10;
            if(num == 0) break;
        }
        if(el == 0) out.print("NO");
        else out.print(el);
    }
}
```

### 3.6 Анализ правильности решения

1. **Тест 1:** Из примера
   ```
   Вход: 13648
   Выход: 3
   ```

2. **Тест 2:** Все цифры чётные
   ```
   Вход: 2468
   Выход: NO
   ```

3. **Тест 3:** Все цифры нечётные
   ```
   Вход: 13579
   Выход: 9
   ```

4. **Тест 4:** Однозначное нечётное
   ```
   Вход: 7
   Выход: 7
   ```

5. **Тест 5:** Однозначное чётное
   ```
   Вход: 4
   Выход: NO
   ```

6. **Тест 6:** Только первая цифра нечётная
   ```
   Вход: 12468
   Выход: 1
   ```

---

## 4. Циклический сдвиг

### 4.1 Постановка задачи

> Дан массив из `n` целых чисел. Выполнить **циклический сдвиг** элементов массива на `k` позиций вправо **без создания дополнительного массива**.
> Вывести массив после перестановки.

### 4.2 Входные и выходные данные

#### Входные данные
1. `n` — размер массива
2. `k` — количество позиций для сдвига
3. `n` целых чисел — элементы массива

| Параметр | Тип данных | Диапазон значений            |
|----------|------------|------------------------------|
| `n`      | `int`      | 1 ≤ n ≤ 100000               |
| `k`      | `int`      | 0 ≤ k ≤ 2147483647           |
| Элементы | `int`      | -2147483648 ≤ x ≤ 2147483647 |

#### Выходные данные
`n` целых чисел — элементы массива после циклического сдвига на `k` позиций вправо.

### 4.3 Выбор структуры данных

| Параметр          | Имя переменной | Тип данных | Назначение           |
|-------------------|----------------|------------|----------------------|
| Размер массива    | `n`            | `int`      | Количество элементов |
| Сдвиг             | `k`            | `int`      | Количество позиций   |
| Массив            | `array`        | `int[]`    | Хранит элементы      |
| Начало подмассива | `start`        | `int`      | Начальный индекс     |
| Конец подмассива  | `end`          | `int`      | Конечный индекс      |
| Временная         | `temp`         | `int`      | Для обмена элементов |
| Счётчик циклов    | `i`            | `int`      | Управление циклами   |

### 4.4 Алгоритм

1. Считать `n`, `k` и заполнить массив `array`
2. Нормализовать `k`: вычислить `k = k % n`
3. Если `k ≠ 0`:
   - Шаг 1: Реверс всего массива
   - Шаг 2: Реверс первых `k` элементов
   - Шаг 3: Реверс оставшихся `n-k` элементов
4. Вывести массив

### 4.5 Программа

```java
package task4;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    private static void cyclicShift(int[] arr, int k) {
        int n = arr.length;
        reverseArray(arr, 0, n - 1);
        reverseArray(arr, 0, k - 1);
        reverseArray(arr, k, n - 1);
    }
    private static void reverseArray(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    public static void main(String[] args) {
        int n = in.nextInt();
        int k = in.nextInt();
        int[] array = new int[n];
        for (int i = 0; i < n; i++) array[i] = in.nextInt();
        k = k % n;
        if(k != 0) cyclicShift(array, k);
        for(int i: array) out.print(i + " ");
    }
}
```

### 4.6 Анализ правильности решения

1. **Тест 1:** Обычный сдвиг
   ```
   Вход: 5 2
         1 2 3 4 5
   Выход: 4 5 1 2 3
   ```

2. **Тест 2:** Сдвиг на длину массива
   ```
   Вход: 4 4
         1 2 3 4
   Выход: 1 2 3 4
   ```

3. **Тест 3:** Большой сдвиг
   ```
   Вход: 3 7
         10 20 30
   Выход: 30 10 20
   ```

4. **Тест 4:** Нулевой сдвиг
   ```
   Вход: 4 0
         5 6 7 8
   Выход: 5 6 7 8
   ```

5. **Тест 5:** Один элемент
   ```
   Вход: 1 100
         42
   Выход: 42
   ```

6. **Тест 6:** Алгоритм с реверсом
   ```
   Вход: 6 2
         1 2 3 4 5 6
   Процесс:
        Исходный: [1, 2, 3, 4, 5, 6]
        Реверс всего: [6, 5, 4, 3, 2, 1]
        Реверс первых 2: [5, 6, 4, 3, 2, 1]
        Реверс остальных 4: [5, 6, 1, 2, 3, 4]
   Выход: 5 6 1 2 3 4
   ```
