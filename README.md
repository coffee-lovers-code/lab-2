## Отчет по лабораторной работе № 1

#### № группы: `ПМ-2501`

#### Выполнил: `Калинин Арсений Александрович`

#### Вариант: `9`

### Cодержание:

- [Первая задача](#1-вывод-закономерности-последовательности)
- [Вторая задача](#2-максимальное-число-подъёмов)
- [Третья задача](#3-вывод-самой-младшей-нечётной-цифры)
- [Четвёртая задача](#4-циклический-сдвиг)

### 1. Вывод закономерности последовательности

### 1.1 Постановка задачи

> С клавиатуры вводятся два целых числа: первое число последовательности (`first`) и количество элементов для вывода (`count`). 
> Последовательность строится по правилу: 
> - если индекс текущего элемента чётный, то к предыдущему элементу прибавляется 4
> - если индекс нечётный, то предыдущий элемент умножается на 3
> 
> Вывести первые `count` элементов последовательности, начиная с вычисленного по правилу значения.

### 1.2 Входные и выходные данные

#### Входные данные
Два целых числа:
1. `first` — начальное значение последовательности
2. `count` — количество элементов для вывода

| Параметр | Тип данных | Диапазон значений |
|----------|------------|-------------------|
| `first`  | `int`      | 2147483647        |
| `count`  | `int`      | 1 ≤ count ≤ 10⁵   |

#### Выходные данные
`count` целых чисел — элементы последовательности, разделённые пробелами.

### 1.3 Выбор структуры данных

| Параметр        | Имя переменной | Тип данных | Назначение                     |
|-----------------|----------------|------------|--------------------------------|
| Начальное число | `first`        | `int`      | Хранит начальное значение      |
| Количество      | `count`        | `int`      | Количество выводимых элементов |
| Счётчик цикла   | `i`            | `int`      | Управление циклом              |

### 1.4 Алгоритм

1. Считать два числа `first` и `count`
2. Использовать цикл `for` от 0 до `count-1`
3. На каждой итерации:
   - Если индекс `i` чётный (`i % 2 == 0`): `first = first + 4`
   - Если индекс `i` нечётный: `first = first * 3`
   - Вывести текущее значение `first`
4. После завершения цикла программа завершается

### 1.5 Программа

```java
package task1;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int first = in.nextInt();
        int count = in.nextInt();
        for(int i = 0; i < count; i++){
            if(i % 2 == 0) first += 4;
            else first *= 3;
            out.print(first + " ");
        }
    }
}
```

### 1.6 Анализ правильности решения

1. **Тест 1:** Первый элемент вычисляется сразу
   ```
   Вход: 1 3
   Выход: 5 15 19
   ```

2. **Тест 2:** Корректное чередование операций
   ```
   Вход: 0 5
   Выход: 4 12 16 48 52
   ```

3. **Тест 3:** Один элемент
   ```
   Вход: 10 1
   Выход: 14
   ```

4. **Тест 4:** Большие значения
   ```
   Вход: 1000000000 2
   Выход: 1000000004 3000000012
   ```

---

### 2. Максимальное число подъёмов

### 2.1 Постановка задачи

> Дана последовательность из `n` целых чисел. Элементы с одинаковой чётностью, идущие подряд, образуют "часть". 
> Для каждой части нужно подсчитать количество "подъёмов" — случаев, когда текущий элемент последовательности **строго больше** предыдущего.
> Вывести максимальное количество подъёмов среди всех частей.

### 2.2 Входные и выходные данные

#### Входные данные
1. `count` — количество элементов в последовательности
2. `count` целых чисел — сама последовательность

| Параметр | Тип данных | Диапазон значений |
|----------|------------|-------------------|
| `count`  | `int`      | 1 ≤ count ≤ 10⁵   |
| Элементы | `int`      | 2147483647        |

#### Выходные данные
Одно целое число — максимальное количество подъёмов в какой-либо части последовательности.

### 2.3 Выбор структуры данных

| Параметр                 | Имя переменной | Тип данных | Назначение                       |
|--------------------------|----------------|------------|----------------------------------|
| Количество элементов     | `count`        | `int`      | Длина последовательности         |
| Текущий элемент          | `el`           | `int`      | Хранит текущий элемент           |
| Предыдущий элемент       | `past`         | `int`      | Хранит предыдущий элемент        |
| Счётчик для чётных       | `j`            | `int`      | Подъёмы в текущей чётной части   |
| Счётчик для нечётных     | `k`            | `int`      | Подъёмы в текущей нечётной части |
| Результат                | `result`       | `int`      | Максимальное найденное значение  |

### 2.4 Алгоритм

1. Считать количество элементов `count` и первый элемент `el`
2. Инициализировать переменные: `result = 0`, `j = 0`, `k = 0`
3. Для каждого следующего элемента (от второго до последнего):
   - Сохранить предыдущий элемент в `past`
   - Считать новый элемент в `el`
   - Проверить условия:
     - Если оба чётные И оба не равны 0: если `el > past`, увеличить `j`, иначе сбросить `k = 0`
     - Если оба нечётные: если `el > past`, увеличить `k`, иначе сбросить `j = 0`
   - Обновить `result` максимальным значением из `j`, `k`, `result`
4. Вывести `result`

### 2.5 Программа

```java
package task2;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int count = in.nextInt();
        int el = in.nextInt();
        int result = 0;
        int j = 0, k = 0;
        for(int i = 1; i < count; i++){
            int past = el;
            el = in.nextInt();
            if(el % 2 == 0 && past % 2 == 0 && el != 0 && past != 0){
                if(el > past) j++;
                k = 0;
            }
            else if(el % 2 != 0 && past % 2 != 0){
                if(el > past) k++;
                j = 0;
            }
            if(k > result) result = k;
            if(j > result) result = j;
        }
        out.print(result);
    }
}
```

### 2.6 Анализ правильности решения

1. **Тест 1:** Только чётные числа (кроме 0)
   ```
   Вход: 5
         2 4 6 8 10
   Выход: 4
   ```

2. **Тест 2:** Только нечётные числа
   ```
   Вход: 4
         1 3 5 2
   Выход: 2
   ```

3. **Тест 3:** Смена чётности
   ```
   Вход: 6
         1 3 2 4 6 8
   Выход: 2
   ```

4. **Тест 4:** Содержит 0
   ```
   Вход: 5
         0 2 4 0 6
   Выход: 1
   ```

---

### 3. Вывод самой младшей нечётной цифры

### 3.1 Постановка задачи

> Дано натуральное число N. Необходимо найти **самую младшую** (самую правую) нечётную цифру в его десятичной записи. 
> Если в числе нет нечётных цифр, вывести "NO".

### 3.2 Входные и выходные данные

#### Входные данные
Одно натуральное число N.

| Параметр | Тип данных | Диапазон значений    |
|----------|------------|----------------------|
| `num`    | `int`      | 1 ≤ num ≤ 2147483647 |

#### Выходные данные
- Если найдена нечётная цифра: эта цифра
- Иначе: "NO"

### 3.3 Выбор структуры данных

| Параметр            | Имя переменной | Тип данных | Назначение             |
|---------------------|----------------|------------|------------------------|
| Входное число       | `num`          | `int`      | Исходное число         |
| Найденная цифра     | `el`           | `int`      | Младшая нечётная цифра |

### 3.4 Алгоритм

1. Считать число `num`
2. Инициализировать `el = 0`
3. Пока `el == 0` и `num > 0`:
   - Проверить последнюю цифру: если `num % 10 % 2 != 0`, то `el = num % 10`
   - Удалить последнюю цифру: `num = num / 10`
4. Если `el == 0`, вывести "NO"
5. Иначе вывести `el`

### 3.5 Программа

```java
package task3;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int num = in.nextInt();
        int el = 0;
        while(el == 0){
            if(num % 10 % 2 != 0) el = num % 10;
            num /= 10;
            if(num == 0) break;
        }
        if(el == 0) out.print("NO");
        else out.print(el);
    }
}
```

### 3.6 Анализ правильности решения

1. **Тест 1:** Нечётная последняя цифра
   ```
   Вход: 123456
   Выход: 5
   ```

2. **Тест 2:** Все цифры чётные
   ```
   Вход: 2468
   Выход: NO
   ```

3. **Тест 3:** Нечётная в середине
   ```
   Вход: 246835
   Выход: 5
   ```

4. **Тест 4:** Однозначное нечётное
   ```
   Вход: 7
   Выход: 7
   ```

5. **Тест 5:** Однозначное чётное
   ```
   Вход: 4
   Выход: NO
   ```

---

### 4. Циклический сдвиг

### 4.1 Постановка задачи

> Дан массив из `n` целых чисел. Выполнить **циклический сдвиг** элементов массива на `k` позиций вправо **без создания дополнительного массива**.
> Вывести массив после перестановки.

### 4.2 Входные и выходные данные

#### Входные данные
1. `n` — размер массива
2. `k` — количество позиций для сдвига
3. `n` целых чисел — элементы массива

| Параметр | Тип данных | Диапазон значений            |
|----------|------------|------------------------------|
| `n`      | `int`      | 1 ≤ n ≤ 2147483647           |
| `k`      | `int`      | 0 ≤ k ≤ 2147483647           |
| Элементы | `int`      | -2147483648 ≤ x ≤ 2147483647 |

#### Выходные данные
`n` целых чисел — элементы массива после циклического сдвига на `k` позиций вправо.

### 4.3 Выбор структуры данных

| Параметр          | Имя переменной | Тип данных | Назначение           |
|-------------------|----------------|------------|----------------------|
| Размер массива    | `n`            | `int`      | Количество элементов |
| Сдвиг             | `k`            | `int`      | Количество позиций   |
| Массив            | `m`            | `int[]`    | Хранит элементы      |
| Временная         | `last`         | `int`      | Для обмена элементов |
| Временная         | `el`           | `int`      | Для обмена элементов |
| Счётчики циклов   | `i`, `j`       | `int`      | Управление циклами   |

### 4.4 Алгоритм

1. Считать `n`, `k` и заполнить массив `m`
2. Выполнить `k` раз:
   - Сохранить первый элемент в `last`
   - Для каждого элемента от первого до предпоследнего:
     - Сохранить следующий элемент в `el`
     - Записать `last` в следующую позицию
     - Присвоить `last = el`
   - Записать `last` в первую позицию
3. Вывести массив

### 4.5 Программа

```java
package task4;
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int n = in.nextInt(), k = in.nextInt();
        int[] m = new int[n];
        for(int i = 0; i < n; i++) m[i] = in.nextInt();
        for(int i = 0; i < k; i++){
            int last = m[0];
            for(int j = 0; j < n-1; j++){
                int el = m[j+1];
                m[j+1] = last;
                last = el;
            }
            m[0] = last;
        }
        for(int i: m) out.print(i + " ");
    }
}
```

### 4.6 Анализ правильности решения

1. **Тест 1:** Обычный сдвиг
   ```
   Вход: 5 2
         1 2 3 4 5
   Выход: 4 5 1 2 3
   ```

2. **Тест 2:** Сдвиг на длину массива
   ```
   Вход: 4 4
         1 2 3 4
   Выход: 1 2 3 4
   ```

3. **Тест 3:** Большой сдвиг
   ```
   Вход: 3 7
         10 20 30
   Выход: 30 10 20
   ```

4. **Тест 4:** Нулевой сдвиг
   ```
   Вход: 4 0
         5 6 7 8
   Выход: 5 6 7 8
   ```

5. **Тест 5:** Один элемент
   ```
   Вход: 1 100
         42
   Выход: 42
   ```
